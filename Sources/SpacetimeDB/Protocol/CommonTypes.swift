//
//  CommonTypes.swift
//  SpacetimeDB
//
//  Common types used across protocol messages.
//

import Foundation

// MARK: - Protocol Constants

/// WebSocket subprotocol for text/JSON encoding.
public let TEXT_PROTOCOL = "v1.json.spacetimedb"

/// WebSocket subprotocol for binary/BSATN encoding.
public let BIN_PROTOCOL = "v1.bsatn.spacetimedb"

// MARK: - QueryId

/// An opaque identifier generated by the client to refer to a subscription.
///
/// Used in Unsubscribe messages and subscription errors.
/// Query IDs only have meaning within a single connection.
public struct QueryId: Hashable, Sendable {
    public let id: UInt32
    
    public init(_ id: UInt32) {
        self.id = id
    }
}

extension QueryId: BSATNCodable {
    public func encode(to encoder: inout BSATNEncoder) throws {
        encoder.encode(id)
    }
    
    public init(from decoder: inout BSATNDecoder) throws {
        self.id = try decoder.decode(UInt32.self)
    }
}

extension QueryId: CustomStringConvertible {
    public var description: String {
        "QueryId(\(id))"
    }
}

// MARK: - CallReducerFlags

/// Flags that can be passed when calling a reducer.
public enum CallReducerFlags: UInt8, Sendable {
    /// The reducer's caller does want to be notified about the reducer completing successfully
    /// regardless of whether the caller had subscribed to a relevant query.
    ///
    /// This is the default flag.
    case fullUpdate = 0
    
    /// The reducer's caller does not want to be notified about the reducer completing successfully
    /// without having subscribed to any of the relevant queries.
    case noSuccessNotify = 1
}

extension CallReducerFlags: BSATNCodable {
    public func encode(to encoder: inout BSATNEncoder) throws {
        encoder.encode(rawValue)
    }
    
    public init(from decoder: inout BSATNDecoder) throws {
        let rawValue = try decoder.decode(UInt8.self)
        guard let flags = CallReducerFlags(rawValue: rawValue) else {
            throw BSATNDecodingError.invalidEnumTag(tag: rawValue, typeName: "CallReducerFlags")
        }
        self = flags
    }
}

// MARK: - CallProcedureFlags

/// Reserved flags for procedure calls.
public enum CallProcedureFlags: UInt8, Sendable {
    /// Default flag value.
    case `default` = 0
}

extension CallProcedureFlags: BSATNCodable {
    public func encode(to encoder: inout BSATNEncoder) throws {
        encoder.encode(rawValue)
    }
    
    public init(from decoder: inout BSATNDecoder) throws {
        let rawValue = try decoder.decode(UInt8.self)
        guard let flags = CallProcedureFlags(rawValue: rawValue) else {
            throw BSATNDecodingError.invalidEnumTag(tag: rawValue, typeName: "CallProcedureFlags")
        }
        self = flags
    }
}

// MARK: - TableId

/// Identifier for a table within a SpacetimeDB module.
///
/// Clients should prefer table names over table IDs, as names are a stable part
/// of a module's API, whereas table IDs may change between runs.
public struct TableId: Hashable, Sendable {
    public let id: UInt32
    
    public init(_ id: UInt32) {
        self.id = id
    }
}

extension TableId: BSATNCodable {
    public func encode(to encoder: inout BSATNEncoder) throws {
        encoder.encode(id)
    }
    
    public init(from decoder: inout BSATNDecoder) throws {
        self.id = try decoder.decode(UInt32.self)
    }
}

extension TableId: CustomStringConvertible {
    public var description: String {
        "TableId(\(id))"
    }
}

// MARK: - EnergyQuanta

/// Represents energy/credit consumption for reducer execution.
///
/// SpacetimeDB tracks energy usage for billing and rate limiting.
/// Internally stored as a signed 128-bit integer.
public struct EnergyQuanta: Hashable, Sendable {
    /// The energy value as a signed 128-bit integer.
    /// Stored as two UInt64 values (low and high parts).
    private let low: UInt64
    private let high: UInt64
    
    /// Create an EnergyQuanta from low and high 64-bit parts.
    public init(low: UInt64, high: UInt64) {
        self.low = low
        self.high = high
    }
    
    /// Create an EnergyQuanta from a 64-bit signed value.
    public init(_ value: Int64) {
        self.low = UInt64(bitPattern: value)
        self.high = value < 0 ? UInt64.max : 0
    }
    
    /// Create a zero energy value.
    public static var zero: EnergyQuanta {
        EnergyQuanta(low: 0, high: 0)
    }
    
    /// Get the value as Int64 if it fits, otherwise nil.
    public var asInt64: Int64? {
        // Check if value fits in signed 64-bit
        if high == 0 && low <= UInt64(Int64.max) {
            return Int64(low)
        } else if high == UInt64.max && low > UInt64(Int64.max) {
            // Negative value that fits in Int64
            return Int64(bitPattern: low)
        }
        return nil
    }
}

extension EnergyQuanta: BSATNCodable {
    public func encode(to encoder: inout BSATNEncoder) throws {
        // i128 is encoded as two u64 in little-endian order (low first, then high)
        encoder.encode(low)
        encoder.encode(high)
    }
    
    public init(from decoder: inout BSATNDecoder) throws {
        self.low = try decoder.decode(UInt64.self)
        self.high = try decoder.decode(UInt64.self)
    }
}

extension EnergyQuanta: CustomStringConvertible {
    public var description: String {
        if let value = asInt64 {
            return "EnergyQuanta(\(value))"
        }
        return "EnergyQuanta(0x\(String(high, radix: 16))\(String(low, radix: 16, uppercase: false)))"
    }
}

// MARK: - Compression Tags

/// Compression tag indicating no compression.
public let SERVER_MSG_COMPRESSION_TAG_NONE: UInt8 = 0

/// Compression tag indicating Brotli compression.
public let SERVER_MSG_COMPRESSION_TAG_BROTLI: UInt8 = 1

/// Compression tag indicating Gzip compression.
public let SERVER_MSG_COMPRESSION_TAG_GZIP: UInt8 = 2
